
## 第一階段：資料預處理與「歸戶」對應（Data Preparation）

這是整個專案最核心的一步，目的是將破碎的帳號資訊轉化為以「人」為單位的乾淨資料。

1. 建立實體映射表 (Entity Mapping Table)：
    - 讀取 Top200_ig_20260126.csv。.
    - 清理姓名：針對 person_name 進行去空格處理（Trim），並作為唯一識別碼。
    - 標準化帳號：將 ig_name 統一轉為小寫，並建立一個字典（Dictionary），格式為 { '帳號小寫': '網紅姓名' }。

2. 檔案與實體連結 (File-to-Entity Matching)：
    - 掃描資料夾中所有檔案。
    - 利用正則表達式提取檔名前綴（即該檔案的發起者帳號）。
    - 透過映射表，判定該檔案屬於哪位「網紅實體」。如果一位網紅有兩個帳號檔案，它們將在下一步被併入同一個實體中。

3. 批次過濾與邊清單生成 (Filtering & Edge List Generation)：
    - 讀取每個 CSV 內的 username 欄位（被追蹤者）。
    - 關鍵步驟：僅保留那些 username 出現在映射表中的紀錄。
    - 轉換為實體對實體：將原始的 帳號A -> 帳號B 關係，轉換為 網紅甲 -> 網紅乙。

4. 實體關係聚合 (Entity Aggregation)：
    - 聯集邏輯 (OR Logic)：只要網紅甲的帳號 A 或帳號 B，追蹤了網紅乙的帳號 C 或帳號 D，我們就定義「網紅甲 ──> 網紅乙」存在一條邊（Edge）。
    - 去重處理：即使有多個帳號交叉追蹤，在 200x200 的矩陣中，甲對乙的關係仍記為 1。

    >  輸出檔案：

    >  username_edge_list.csv

    >  條列有追蹤母體清單內的網紅


## 第二階段：建立網路關係模型（Network Construction）

在這個階段，我們要處理「一對多帳號」的邏輯，並定義什麼叫作「追蹤」。

1. 節點定義 (Nodes Extraction)：
      - 從 Top200_ig_20260126.csv 提取所有 200 位網紅的 person_name 作為矩陣的標籤（行列座標）。
      - 維持既有的網紅排名

2. 鄰接矩陣 (Adjacency Matrix) 運算：
    - 生成 200x200 的方陣，行列皆為 person_name。
    - 矩陣1：標準鄰接矩陣 (0/1)
        - 用於精確記錄「誰追蹤了誰」。
        - 儲存格值：1 (有追蹤), 0 (無)

        >  輸出檔案：

        >  influencer_adjacency_matrix.csv

        >  200 x 200 的 0/1 矩陣

    - 矩陣2：互惠性矩陣 (0/1/2)
        - 用於快速辨識關係深度。
        - 運算邏輯：將鄰接矩陣與其轉置矩陣相加 (Matrix + Matrix^T)
            - 0 (None)：雙方皆無追蹤。
            - 1 (One-way)：只有一方追蹤另一方（單向崇拜/關注）。
            - 2 (Mutual)：雙方互粉（圈內好友）。
        >  輸出檔案：

        >  influencer_reciprocity_matrix.csv

        >  200 x 200 的 0/1/2 矩陣
  

3. 互粉偵測 (Mutual Detection)：
    - 比較 $Matrix[A, B]$ 與 $Matrix[B, A]$，找出雙向追蹤的清單。
    - 計算 互惠係數 (Reciprocity)：找出矩陣中 $A[i][j]=1$ 且 $A[j][i]=1$ 的對稱點，這代表這兩位網紅是「互粉」，屬於強連結。

3. 計算社群指標 (Network Metrics)：
    - 入度 (In-degree)：誰被最多圈內網紅追蹤？（判定誰是圈內的大前輩）。
    - 被追蹤數 / 潛在最大追蹤數。

    >  輸出檔案：

    >  network_metrics_report.csv

    >  每位網紅的排名表（包含入度-被多少網紅追蹤、出度-追蹤多少網紅、互粉比例-有多少雙向追蹤）。

## 第三階段：視覺化與深度洞察（Visualization & Insights）

最後，我們將抽象的矩陣轉化為直觀的圖表。

1. 關係重組與分群 (Community Detection)
    - 演算法介入：利用 Louvain 或 Girvan-Newman 演算法，根據追蹤關係將 200 人自動分成數個「社群（Communities）」。

    - 重排矩陣 (Clustered Matrix)：

        - 這是「分群重排」。我們會重新排列矩陣的行列，讓同一個社群的人靠在一起。

        - 意義：此時矩陣中會出現明顯的「對角塊狀效應」，每個方塊代表一個利益團體或交友圈。
1. 靜態全局網路圖 (Global Network Graph)：
    - 使用「力導向演算法」（Force-directed layout）。
    - 節點大小：依據「入度中心性」設定，越大的節點代表被越多同業追蹤。
    - 連線顏色：區分「單向追蹤」與「雙向互粉」（例如互粉用粗實線，單向用細虛線）。

2. 社群分群圖 (Community Detection)：
    - 利用演算法自動標記不同的顏色區塊。
    - 洞察價值：這能自動幫你分出例如「親子組」、「美食組」、「科技組」或是「某經紀公司派系」，觀察網紅們的交友圈邊界。

3. 矩陣熱圖 (Clustered Heatmap)：
    - 將矩陣進行重新排序，讓關係緊密的網紅靠在一起。
    - 這能讓出哪些網紅形成了「全連通小圈圈」（即區塊中出現明顯的高密度正方形）。
3. 視覺 A：聚類熱圖 (Clustered Heatmap)

    - 使用 0/1/2 矩陣作為輸入。
    - 顏色區分：0(淡色)、1(中色)、2(深色)。 
    - 老師能看到的價值：一眼看出哪幾個熱搜網紅其實是屬於同一個「小團體」。

3. 視覺 B：力導向社群圖 (Force-Directed Graph)

    - 節點大小：對應「入度 (In-degree)」。
    - 節點顏色：對應自動偵測出的「社群編號」。
    - 連線：區分單向（帶箭頭細線）與雙向（粗實線）。
    - 意義：這張圖會像星系一樣，核心網紅在中間，邊緣網紅在四周，且派系分明。

3. 
4. 互惠排行表：
    - 列出互粉率最高的網紅組合，這對於分析商業合作（如 Guesting 或聯名）非常有價值。
5. 派系摘要報告
    - 產出 community_summary.json 或 csv，列出每個派系的核心人物（通常是該派系中入度最高的人）。